(ns pelo.core
  (:import [javax.swing JFrame JPanel Timer]
           [java.awt Graphics Graphics2D Color RenderingHints]
           [java.awt.event ActionListener]
           [java.util Random]))

(def particle-count 20)
(def particle-size 1)
(def initial-speed 2)
(def gravitational-force 0.3)
(def max-x (- 800 6))
(def min-x (+ 0 6))
(def max-y (- 600 6))
(def min-y (+ 0 6))
(defn random-value [upper-bound] (.nextInt (Random.) upper-bound))
(defn random-operation [] (if (= 1 (random-value 2)) + -))

(def frame (atom nil)) ; Atom to store the frame
;; (def state (atom {:x 300 :y 200 :xd + :yd + :angle 77})) ; Atom to store the state with initial position
(def states (atom
             (vec (map
                   (fn [_]
                     {:x (random-value 599) :y (random-value 599) :xd + :yd + :angle (random-value 360) :x-velocity nil :y-velocity nil}
                     (range particle-count))))))
;; 90 (-270) is down, 270 (-90) is up
(defn log-state []
  (let [state-summary (map (fn [{:keys [x y angle]}]
                             {:x x :y y :angle angle})
                           @states)]
    (println "Current state:" state-summary)))

(defn draw-canvas [^Graphics g]
  (let [g2d (doto ^Graphics2D g
              (.setRenderingHint RenderingHints/KEY_ANTIALIASING RenderingHints/VALUE_ANTIALIAS_ON))]
    (.setColor g2d Color/BLACK)
    (.fillRect g2d 0 0 800 600)))

(defn draw-particle [^Graphics g {:keys [x y xd yd]}]
  (let [g2d (doto ^Graphics2D g
              (.setRenderingHint RenderingHints/KEY_ANTIALIASING RenderingHints/VALUE_ANTIALIAS_ON))]
    (.setColor g2d Color/RED)
    (.fillOval g2d x y particle-size particle-size)))

(defn update-position-trig-experimental [state]
  (let [{:keys [x y xd yd angle]} state
        new-angle (+ angle 3)
        ;; new-xd (if (odd? (mod (int (Math/ceil (/ new-angle 265))) 265)) + -)
        ;; new-yd new-xd
        new-x (+ x (* (- initial-speed (/ angle 1000)) (Math/cos (Math/toRadians (xd 0 new-angle)))))
        new-y (+ y (* (- initial-speed (/ angle 1000)) (Math/sin (Math/toRadians (xd 0 new-angle)))))]
    {:x new-x :y new-y :xd xd :yd yd :angle new-angle}))

(defn update-position-trig [state]
  (let [{:keys [x y xd yd angle]} state
        new-xd (if (>= x (- max-x 6)) - (if (<= x 0) + xd))
        new-yd (if (>= y (- max-y 6)) - (if (<= y 0) + yd))
        ;; new-angle (+ angle
        ;;              (- (reduce + (mapv
        ;;                            (fn [x] (if x 180 0))
        ;;                            [(and (not= new-xd xd) (= new-xd -)) (and (not= new-yd yd) (= new-yd +))]))
        ;;                 (reduce + (mapv
        ;;                            (fn [x] (if x 180 0))
        ;;                            [(and (not= new-xd xd) (= new-xd +)) (and (not= new-yd yd) (= new-yd -))]))))
        ;; new-angle (if (or (not= new-xd xd) (not= new-yd yd)) (- 90 angle) angle)
        new-angle angle
        new-x (new-xd x (* initial-speed (Math/cos (Math/toRadians (+ 0 new-angle)))))
        new-y (new-yd y (* initial-speed (Math/sin (Math/toRadians (+ 0 new-angle)))))]
    {:x new-x :y new-y :xd new-xd :yd new-yd :angle new-angle}))

(defn update-position [state]
  (let [{:keys [x y xd yd]} state
        new-xd (if (>= x max-x) - (if (<= x 0) + xd))
        new-yd (if (>= y max-y) - (if (<= y 0) + yd))
        new-x (new-xd x initial-speed)
        new-y (new-yd y initial-speed)]
    {:x new-x :y new-y :xd new-xd :yd new-yd}))

(defn apply-move [state]
  (let [{:keys [x y xd yd angle x-velocity y-velocity]} state
        ;; new-xd (if (>= x (- max-x 6)) - (if (<= x 0) + xd))
        ;; new-yd (if (>= y (- max-y 6)) - (if (<= y 0) + yd))
        new-x-velocity (if (nil? x-velocity) (* initial-speed (Math/cos (Math/toRadians angle))) x-velocity)
        new-y-velocity (if (nil? y-velocity) (* initial-speed (Math/sin (Math/toRadians angle))) y-velocity)
        new-angle angle
        new-x (+ x x-velocity)
        new-y (+ y y-velocity)]
    [state {:x new-x :y new-y :xd xd :yd yd :angle new-angle :x-velocity new-x-velocity :y-velocity new-y-velocity}]))

(defn bounce [pos distance boundary]
  (let [allowed-distance (- boundary pos)]
    (+ pos (- (* 2 allowed-distance) distance))))

(defn degrees-from-y-x [y x] (- 360 (Math/toDegrees (Math/atan2 y x))))

;; âŒ this doesn't kill momentum
;; (maybe we need to introduce acceleration (change of velocity) in our game)
;; (defn apply-gravity [state]
;;   (let [{:keys [x y xd yd angle]} state
;;         destination-angle (if (< angle 0) -270 90)
;;         diff-towards-destination (- destination-angle angle)
;;         new-angle (if (= 0 diff-towards-destination) angle (+ angle (/ diff-towards-destination (Math/abs diff-towards-destination))))]
;;     {:x x :y y :xd xd :yd yd :angle new-angle}))

;; acceleration...
(defn apply-gravity [[old-state new-state]]
  (let [{old-x :x old-y :y old-xd :xd old-yd :yd old-angle :angle} old-state
        {new-x :x new-y :y new-xd :xd new-yd :yd new-angle :angle} new-state
        destination-angle (if (< new-angle 0) -270 90)
        diff-towards-destination (- destination-angle new-angle)
        gravity-y (+ new-y (if (= 0 diff-towards-destination) 0 (* gravitational-force (/ diff-towards-destination (Math/abs diff-towards-destination)))))
        new-angle (degrees-from-y-x
                   (-  gravity-y  old-y)
                   (-  new-x  old-x))]
    [new-state {:x new-x :y gravity-y :xd new-xd :yd new-yd :angle new-angle}]))

(defn toggle-direction [dir] (if (= dir -) + -))

(defn apply-bounce [[old-state new-state]]
  (let [{old-x :x old-y :y old-xd :xd old-yd :yd old-angle :angle} old-state
        {new-x :x new-y :y new-xd :xd new-yd :yd new-angle :angle} new-state
        ;; -----
        is-x-upper-bounce (>= new-x max-x)
        is-x-lower-bounce (<= new-x min-x)
        is-y-upper-bounce (>= new-y max-y)
        is-y-lower-bounce (<= new-y min-y)
        is-x-bounce (or is-x-upper-bounce is-x-lower-bounce)
        is-y-bounce (or is-y-upper-bounce is-y-lower-bounce)
        dx (- new-x old-x)
        dy (- new-y old-y)
        bounce-x (if is-x-upper-bounce
                   (min (bounce old-x dx max-x) (- max-x 0.1))
                   (if is-x-lower-bounce
                     (max (bounce old-x dx min-x) (+ min-x 0.1))
                     new-x))
        bounce-y (if is-y-upper-bounce
                   (min (bounce old-y dy max-y) (- max-y 0.1))
                   (if is-y-lower-bounce
                     (max (bounce old-y dy min-y) (+ min-y 0.1))
                     new-y))
        bounce-xd (if (not= bounce-x new-x) (toggle-direction new-xd) new-xd)
        bounce-yd (if (not= bounce-y new-y) (toggle-direction new-yd) new-yd)
        bounce-angle (if is-x-bounce (- 180 new-angle) (if is-y-bounce (- 360 new-angle) new-angle))
        ;; .....
        ]
    ;; (print is-x-upper-bounce bounce-x, new-x old-x dx)
    [new-state {:x bounce-x :y bounce-y :xd bounce-xd :yd bounce-yd :angle bounce-angle}]))

(defn update-state [states]
  (let [move-transition (mapv apply-move states)
        gravity-transition (mapv apply-gravity move-transition)
        bounce-transition (mapv apply-bounce gravity-transition)] (mapv last bounce-transition)))

(defn game-panel []
  (proxy [JPanel ActionListener] []
    (paintComponent [^Graphics g]
      (proxy-super paintComponent g)
      (draw-canvas g)
      (doseq [state @states] (draw-particle g state))
      ;; (draw-particle g @state))
      )
    (actionPerformed [_]
      ;; (swap! states (fn [sts] (mapv update-position-trig sts))) ; Update the x position 
      (swap! states update-state) ; Update the x position 
      (.repaint this))))

(defn create-frame []
  (when-let [f @frame]
    (.dispose f) ; Close the existing frame if it exists
    (reset! frame nil))  ; Reset the frame atom
  (let [panel (game-panel)
        new-frame (doto (JFrame. (str "Java2D Game Example" initial-speed))
                    (.setContentPane panel)
                    (.setSize 800 620)
                    (.setDefaultCloseOperation JFrame/DISPOSE_ON_CLOSE)
                    (.setVisible true))
        timer (Timer. 16 panel) ; Correctly instantiate the Timer
        ;; log-timer (Timer. 1000 (proxy [ActionListener] [] ; Logging timer
        ;;                          (actionPerformed [_]
        ;;                            (log-state)))) ; Log the state every 1000 ms (1 second)
        ;; ---
        ]
    (.start timer)
    ;; (.start log-timer)
    (reset! frame new-frame))) ; Store the new frame in the atom

(defn start-game []
  (create-frame))

(comment
  (Math/cos (Math/toRadians 30))
  (Math/sin (Math/toRadians 30))

  (int (mod (Math/ceil (/ 451 450)) 450))
  (map (fn [x] (dec x)) (range 10))

  (update-position-trig {:x 0, :y -0.6560590289905074, :angle (+ 221 270) :xd + :yd +})

  (def angle (random-value 360))
  (def x-velocity (* initial-speed (Math/cos (Math/toRadians angle))))
  (def y-velocity (* initial-speed (Math/sin (Math/toRadians angle))))
  (def bm-map {:x 750 :y (random-value 599) :xd + :yd + :angle angle :x-velocity x-velocity :y-velocity y-velocity})
  (def moved-bm-map (apply-move bm-map))
  (apply-bounce [bm-map moved-bm-map])
  (apply-gravity moved-bm-map)
  (print bm-map moved-bm-map)
  (degrees-from-y-x
   (-  (:y moved-bm-map)  (:y bm-map))
   (-  (:x moved-bm-map)  (:x bm-map)))
  (:angle moved-bm-map)

  (Math/tan (Math/toRadians 45))
  (degrees-from-y-x 1 1)
  (Math/sqrt 3)

  ;; end
  )


