(ns pelo.core
  (:import [javax.swing JFrame JPanel Timer]
           [java.awt Graphics Graphics2D Color RenderingHints]
           [java.awt.event ActionListener]
           [java.util Random]))

(def frames-per-second 60)
(def ticks-per-second (/ 1000 frames-per-second))
(def particle-count 2)
(def particle-size 2)
(def initial-velocity 2) ;; px per tick
(def gravitational-force 0.3)
(def max-x (- 800 6))
(def min-x (+ 0 6))
(def max-y (- 600 6))
(def min-y (+ 0 6))
(defn random-value [upper-bound] (.nextInt (Random.) upper-bound))

(def frame (atom nil)) ; Atom to store the frame

(def states (atom
             (vec (map
                   (fn [_]
                     {:x (random-value 599) :y (random-value 599) :angle (random-value 360) :x-velocity nil :y-velocity nil})
                   (range particle-count)))))

(defn draw-canvas [^Graphics g]
  (let [g2d (doto ^Graphics2D g
              (.setRenderingHint RenderingHints/KEY_ANTIALIASING RenderingHints/VALUE_ANTIALIAS_ON))]
    (.setColor g2d Color/BLACK)
    (.fillRect g2d 0 0 800 600)))

(defn draw-particle [^Graphics g {:keys [x y]}]
  (let [g2d (doto ^Graphics2D g
              (.setRenderingHint RenderingHints/KEY_ANTIALIASING RenderingHints/VALUE_ANTIALIAS_ON))]
    (.setColor g2d Color/WHITE)
    (.fillOval g2d x y particle-size particle-size)))

(defn bounce [pos distance boundary]
  (let [allowed-distance (- boundary pos)]
    (+ pos (- (* 2 allowed-distance) distance))))

(defn degrees-from-y-x [y x] (- 360 (Math/toDegrees (Math/atan2 y x))))

(defn apply-gravity [[old-state new-state]]
  (let [{old-x :x old-y :y} old-state
        {new-x :x new-y :y new-xd :xd new-yd :yd new-angle :angle new-y-velocity :y-velocity new-x-velocity :x-velocity} new-state
        gravity-y-velocity (+ new-y-velocity gravitational-force)
        ;; new-angle (degrees-from-y-x
        ;;            (-  new-y  old-y)
        ;;            (-  new-x  old-x))
        ;; ---
        ]
    [new-state {:x new-x :y new-y :xd new-xd :yd new-yd :angle new-angle :x-velocity new-x-velocity :y-velocity gravity-y-velocity}]))

(defn toggle-direction [dir] (if (= dir -) + -))

;; adding to 
(defn apply-move [state]
  (let [{:keys [x y angle x-velocity y-velocity]} state
        new-x-velocity (if (nil? x-velocity) (* initial-velocity (Math/cos (Math/toRadians angle))) x-velocity)
        new-y-velocity (+ (if (nil? y-velocity)
                            (* initial-velocity (Math/sin (Math/toRadians angle)))
                            y-velocity) gravitational-force)
        x-move (+ x new-x-velocity)
        y-move (+ y new-y-velocity)
        new-x (+ x x-move)
        new-y (+ y y-move)] 
    (print angle)
    [state {:x new-x :y new-y :angle angle :x-velocity x-velocity :y-velocity y-velocity}]))


(defn apply-bounce [[old-state new-state]]
  (let [{old-x :x old-y :y old-xd :xd old-yd :yd old-angle :angle} old-state
        {new-x :x new-y :y new-xd :xd new-yd :yd new-angle :angle} new-state
        ;; -----
        is-x-upper-bounce (>= new-x max-x)
        is-x-lower-bounce (<= new-x min-x)
        is-y-upper-bounce (>= new-y max-y)
        is-y-lower-bounce (<= new-y min-y)
        is-x-bounce (or is-x-upper-bounce is-x-lower-bounce)
        is-y-bounce (or is-y-upper-bounce is-y-lower-bounce)
        dx (- new-x old-x)
        dy (- new-y old-y)
        bounce-x (if is-x-upper-bounce
                   (min (bounce old-x dx max-x) (- max-x 0.1))
                   (if is-x-lower-bounce
                     (max (bounce old-x dx min-x) (+ min-x 0.1))
                     new-x))
        bounce-y (if is-y-upper-bounce
                   (min (bounce old-y dy max-y) (- max-y 0.1))
                   (if is-y-lower-bounce
                     (max (bounce old-y dy min-y) (+ min-y 0.1))
                     new-y))
        bounce-xd (if (not= bounce-x new-x) (toggle-direction new-xd) new-xd)
        bounce-yd (if (not= bounce-y new-y) (toggle-direction new-yd) new-yd)
        bounce-angle (if is-x-bounce (- 180 new-angle) (if is-y-bounce (- 360 new-angle) new-angle))
        ;; .....
        ]
    [new-state {:x bounce-x :y bounce-y :xd bounce-xd :yd bounce-yd :angle bounce-angle}]))

(defn update-state [states]
  (let [move-transition (mapv apply-move states)
        ;; gravity-transition (mapv apply-gravity move-transition)
        ;; bounce-transition (mapv apply-bounce move-transition)
        ;; --
        ](mapv last move-transition)))

(defn game-panel []
  (proxy [JPanel ActionListener] []
    (paintComponent [^Graphics g]
      (proxy-super paintComponent g)
      (draw-canvas g)
      (doseq [state @states] (draw-particle g state))
      )
    (actionPerformed [_]
      (swap! states update-state) ; Update the x position 
      (.repaint this))))

(defn create-frame []
  (when-let [f @frame]
    (.dispose f) ; Close the existing frame if it exists
    (reset! frame nil))  ; Reset the frame atom
  (let [panel (game-panel)
        new-frame (doto (JFrame. (str "Java2D Game Example" initial-velocity))
                    (.setContentPane panel)
                    (.setSize 800 620)
                    (.setDefaultCloseOperation JFrame/DISPOSE_ON_CLOSE)
                    (.setVisible true))
        timer (Timer. 16 panel)
        ;; ---
        ]
    (.start timer)
    ;; (.start log-timer)
    (reset! frame new-frame))) ; Store the new frame in the atom

(defn start-game []
  (create-frame))

(comment

  ;; end
  )


